import * as fs from "fs/promises"
import { globby } from "globby"
import * as path from "path"
import { createServiceNameMap, parseProtoForServices } from "./scripts/proto-shared-utils.mjs"

const ROOT_DIR = "."
const PROTO_DIR = path.resolve("proto")
const GO_PROTO_DIR = path.join("src", "generated", "grpc-go")
const GO_CLIENT_DIR = path.join(GO_PROTO_DIR, "client")
const GO_SERVICE_CLIENT_DIR = path.join(GO_CLIENT_DIR, "services")

const COMMON_TYPES = ["StringRequest", "EmptyRequest", "Empty", "String", "Int64Request", "KeyValuePair"]

async function generateGoConnection() {
	console.log("Generating Go connection manager...")

	await fs.mkdir(GO_CLIENT_DIR, { recursive: true })

	const content = `// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by generate-clients.mjs

package client

import (
	"context"
	"fmt"
	"sync"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// ConnectionConfig holds configuration for gRPC connection
type ConnectionConfig struct {
	Address string
	Timeout time.Duration
}

// ConnectionManager manages gRPC connections
type ConnectionManager struct {
	config *ConnectionConfig
	conn   *grpc.ClientConn
	mutex  sync.RWMutex
}

// NewConnectionManager creates a new connection manager
func NewConnectionManager(config *ConnectionConfig) *ConnectionManager {
	if config.Timeout == 0 {
		config.Timeout = 30 * time.Second
	}

	return &ConnectionManager{
		config: config,
	}
}

// Connect establishes a gRPC connection
func (cm *ConnectionManager) Connect(ctx context.Context) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	if cm.conn != nil {
		return nil // Already connected
	}

	connectCtx, cancel := context.WithTimeout(ctx, cm.config.Timeout)
	defer cancel()

	conn, err := grpc.DialContext(connectCtx, cm.config.Address,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return fmt.Errorf("failed to connect to %s: %w", cm.config.Address, err)
	}

	cm.conn = conn
	return nil
}

// Disconnect closes the gRPC connection
func (cm *ConnectionManager) Disconnect() error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	if cm.conn == nil {
		return nil // Already disconnected
	}

	err := cm.conn.Close()
	cm.conn = nil
	return err
}

// GetConnection returns the current gRPC connection
func (cm *ConnectionManager) GetConnection() *grpc.ClientConn {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()
	return cm.conn
}

// IsConnected returns true if connected
func (cm *ConnectionManager) IsConnected() bool {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()
	return cm.conn != nil
}
`

	const connectionPath = path.join(GO_CLIENT_DIR, "connection.go")
	await fs.writeFile(connectionPath, content)
	console.log("Generated Go connection manager at", connectionPath)
}

async function generateGoClient() {
	console.log("Generating Go client...")

	const protoFiles = await globby("**/*.proto", { cwd: PROTO_DIR })
	const services = await parseProtoForServices(protoFiles, PROTO_DIR)
	const serviceNameMap = createServiceNameMap(services)

	const serviceClients = Object.keys(serviceNameMap)
		.map(
			(name) =>
				`\t${name.charAt(0).toUpperCase() + name.slice(1)} *services.${name.charAt(0).toUpperCase() + name.slice(1)}Client`,
		)
		.join("\n")

	const serviceInitializers = Object.keys(serviceNameMap)
		.map(
			(name) =>
				`\tc.${name.charAt(0).toUpperCase() + name.slice(1)} = services.New${name.charAt(0).toUpperCase() + name.slice(1)}Client(conn)`,
		)
		.join("\n")

	const serviceNilOut = Object.keys(serviceNameMap)
		.map((name) => `\tc.${name.charAt(0).toUpperCase() + name.slice(1)} = nil`)
		.join("\n")

	const content = `// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by generate-clients.mjs

package client

import (
	"context"
	"fmt"
	"sync"

	"google.golang.org/grpc"
	"github.com/cline/grpc-go/client/services"
)

// ClineClient provides a unified interface to all Cline services
type ClineClient struct {
	connManager *ConnectionManager
	
	// Service clients
${serviceClients}
	
	// Connection state
	mutex     sync.RWMutex
	connected bool
}

// NewClineClient creates a new unified Cline client
func NewClineClient(address string) (*ClineClient, error) {
	config := &ConnectionConfig{
		Address: address,
	}
	
	connManager := NewConnectionManager(config)
	
	return &ClineClient{
		connManager: connManager,
	}, nil
}

// NewClineClientWithConfig creates a new Cline client with custom configuration
func NewClineClientWithConfig(config *ConnectionConfig) (*ClineClient, error) {
	connManager := NewConnectionManager(config)
	
	return &ClineClient{
		connManager: connManager,
	}, nil
}

// Connect establishes connection to Cline Core and initializes service clients
func (c *ClineClient) Connect(ctx context.Context) error {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	
	if c.connected {
		return nil
	}
	
	// Establish gRPC connection
	if err := c.connManager.Connect(ctx); err != nil {
		return fmt.Errorf("failed to connect: %w", err)
	}
	
	// Initialize service clients
	conn := c.connManager.GetConnection()
${serviceInitializers}
	
	c.connected = true
	return nil
}

// Disconnect closes the connection to Cline Core
func (c *ClineClient) Disconnect() error {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	
	if !c.connected {
		return nil
	}
	
	err := c.connManager.Disconnect()
	c.connected = false
	
	// Clear service clients
${serviceNilOut}
	
	return err
}

// IsConnected returns true if the client is connected to Cline Core
func (c *ClineClient) IsConnected() bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	return c.connected
}

// Reconnect closes the current connection and establishes a new one
func (c *ClineClient) Reconnect(ctx context.Context) error {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	
	// Disconnect first
	if c.connected {
		if err := c.connManager.Disconnect(); err != nil {
			return fmt.Errorf("failed to disconnect: %w", err)
		}
		c.connected = false
	}
	
	// Reconnect
	if err := c.connManager.Connect(ctx); err != nil {
		return fmt.Errorf("failed to reconnect: %w", err)
	}
	
	// Reinitialize service clients
	conn := c.connManager.GetConnection()
${serviceInitializers}
	
	c.connected = true
	return nil
}

// GetConnection returns the underlying gRPC connection
func (c *ClineClient) GetConnection() *grpc.ClientConn {
	return c.connManager.GetConnection()
}
`

	const clientPath = path.join(GO_CLIENT_DIR, "cline_client.go")
	await fs.writeFile(clientPath, content)
	console.log("Generated Go client at", clientPath)
}

async function generateGoServiceClients() {
	console.log("Generating Go service clients...")
	await fs.mkdir(GO_SERVICE_CLIENT_DIR, { recursive: true })

	const protoFiles = await globby("**/*.proto", { cwd: PROTO_DIR })
	const services = await parseProtoForServices(protoFiles, PROTO_DIR)

	for (const [serviceName, serviceDef] of Object.entries(services)) {
		const capitalizedServiceName = serviceName.charAt(0).toUpperCase() + serviceName.slice(1)
		const clientFileName = `${serviceName}_client.go`
		const clientPath = path.join(GO_SERVICE_CLIENT_DIR, clientFileName)

		const methods = serviceDef.methods
			.map((method) => {
				const capitalizedMethodName = method.name.charAt(0).toUpperCase() + method.name.slice(1)

				const requestTypeName = method.requestType.split(".").pop()
				const responseTypeName = method.responseType.split(".").pop()

				const requestType = COMMON_TYPES.includes(requestTypeName)
					? `*cline.${requestTypeName}`
					: `*proto.${requestTypeName}`
				const responseType = COMMON_TYPES.includes(responseTypeName)
					? `*cline.${responseTypeName}`
					: `*proto.${responseTypeName}`

				if (method.isResponseStreaming) {
					return `
// ${capitalizedMethodName} subscribes to ${method.name} updates and returns a stream
func (sc *${capitalizedServiceName}Client) ${capitalizedMethodName}(ctx context.Context, req ${requestType}) (proto.${serviceDef.name}_${capitalizedMethodName}Client, error) {
	stream, err := sc.client.${capitalizedMethodName}(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to ${method.name}: %w", err)
	}

	return stream, nil
}`
				} else {
					return `
// ${capitalizedMethodName} retrieves the current application ${method.name}
func (sc *${capitalizedServiceName}Client) ${capitalizedMethodName}(ctx context.Context, req ${requestType}) (${responseType}, error) {
	resp, err := sc.client.${capitalizedMethodName}(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest ${method.name}: %w", err)
	}

	return resp, nil
}`
				}
			})
			.join("\n")

		const protoImportPath =
			serviceDef.protoPackage === "host" ? '"github.com/cline/grpc-go/host"' : '"github.com/cline/grpc-go/cline"'

		const needsClineImport = serviceDef.methods.some((method) => {
			const requestTypeName = method.requestType.split(".").pop()
			const responseTypeName = method.responseType.split(".").pop()
			return COMMON_TYPES.includes(requestTypeName) || COMMON_TYPES.includes(responseTypeName)
		})

		const clineImport = needsClineImport ? '	cline "github.com/cline/grpc-go/cline"\n' : ""

		const content = `// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by generate-clients.mjs

package services

import (
	"context"
	"fmt"

${clineImport}	proto ${protoImportPath}
	"google.golang.org/grpc"
)

// ${capitalizedServiceName}Client wraps the generated ${serviceDef.name} gRPC client
type ${capitalizedServiceName}Client struct {
	client proto.${serviceDef.name}Client
}

// New${capitalizedServiceName}Client creates a new ${capitalizedServiceName}Client
func New${capitalizedServiceName}Client(conn *grpc.ClientConn) *${capitalizedServiceName}Client {
	return &${capitalizedServiceName}Client{
		client: proto.New${serviceDef.name}Client(conn),
	}
}
${methods}
`

		await fs.writeFile(clientPath, content)
		console.log("Generated Go service client at", clientPath)
	}
}

async function main() {
	try {
		console.log("Generating Go client wrapper files...")

		await generateGoConnection()
		await generateGoClient()
		await generateGoServiceClients()

		console.log("Go client generation complete!")
	} catch (error) {
		console.error("Error generating Go clients:", error)
		process.exit(1)
	}
}

main()
